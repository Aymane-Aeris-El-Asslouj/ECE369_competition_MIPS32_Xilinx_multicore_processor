# Competition MIPS32 Xilinx 32-core Processor Block
This repository contains the Verilog code for my 32-core MIPS32 processor on FPGA. I wrote it for the processor on FPGA designed competition in the Computer Architecture course ECE 369 at the University of Arizona. It was built on top of [my single-core processor](https://github.com/Aymane-Aeris-El-Asslouj/ECE369_MIPS32_Xilinx_processor) and [my implementation of the SAD algorithm](https://github.com/Aymane-Aeris-El-Asslouj/ECE369_MIPS32_SAD_Assembly_code) designed for the same class. This implementation showcases a pipelined architecture for a subset of the MIPS32 instruction set. It can be used as a basis for a full multicore MIPS32 processor implementation by adding missing features like a Floating Point Unit (FPU), cache levels, and exception handling.

## Competition
The ECE 369 class had as its final project a class-wide competition to see who can make the best processor for their implementation of the SAD algorithm. The competition had multiple categories including execution time, critical path delay, number of clock cycles, and FPGA fabric usage. I made a multicore to compete in the execution time, critical path delay, and number of clock cycles categories. Out of the 17 entries, my design won 1st place for the shortest execution time category and 2nd place in the shortest critical path delay category.

## Hardware
This processor block was written for the [Digilent Nexys 4 board](https://digilent.com/reference/programmable-logic/nexys-4/start) containing the [Xilinx Artix-7 FPGA](https://www.xilinx.com/products/silicon-devices/fpga/artix-7.html), but it can be easily adapted to any other board and FPGA by modifying the contraint file [Two4DigitDisplay.xdc](constraints/Two4DigitDisplay.xdc). At the FPGA level, the block's inputs are the board oscillator pin as a clock and a push-button pin as a user reset button. The block's outputs are the pins for the 8-digit 7-segment display.

## File Structure
The main content is the [Verilog source files](sources) in which the multicore processor hardware description code is written. The repository also contains the single-core and multicore [simulation testbenches](test_benches) and the [contraint file](constraints/Two4DigitDisplay.xdc) for the FPGA board. My [multi-threaded implementation of the SAD algorithm using custom instructions](multithread_SAD_program) is provided with the instruction and memory file for each core.

## Setup
The Verilog code was sucessfully sythesized and tested with the Artix-7 FPGA using the [Xilinx Vivado IDE](https://www.xilinx.com/products/design-tools/vivado.html). I would recommend creating a new project with the XC7A100T-1CSG324C FPGA target and copying the files into its source directory. [The top level file](sources/top_level.v) should be set as the top level block before running simulations or synthesis.

## Top Level Structure
The [top level file](sources/top_level.v) connects the high-level blocks. The processor's output, which is the last written register value, is passed to the [8-digit 7-segment display driver block](sources/Two4DigitDisplay.v) which uses the [7-segment display driver block](sources/SevenSegment.v). The processor is driven by the board oscillator input passed through a [clock divider](sources/ClkDiv.v). The divider ensures the processor is slow enough for the user to see the written register values change on the display.

## Multicore Structure
The [multicore processor](sources/MultiCore.v) is split into 32 cores. One core is the parent and the rest are child cores. Each child core is connected to the parent core with a buffer which acts as a data transmission line. Each core has its own instruction and data memories allowing them to run different programs or one multi-threaded program. The output of the processor is the new value of the last register written by the parent core.  

## Original Pipeline Structure
![Original core pipeline](/schematic.png)
The original [core pipeline](sources/Processor.v) was split into five stages as shown in the schematic above. Instruction Fetch (IF), Instruction Decode (ID), Execution (EX), Memory (MEM), and Write Back (WB). The stages are separated by [pipeline registers](sources/PipeReg.v) that buffer the output of each stage for the next clock cycle. The [IF unit](sources/InstructionFetchUnit.v) handles the [program counter](sources/ProgramCounter.v) and reads from the [instruction memory](sources/InstructionMemory.v). The [ID unit](sources/InstructionDecodeUnit.v) decode the instruction into the right register values from its [register file](sources/RegisterFile.v) and control signals using the [control unit](sources/ControlUnit.v) and [compare unit](sources/ComapreUnit.v). The [Ex unit](sources/ExecutionUnit.v) makes requested ahrithmetic operations using the [Ahrithmetic and Logic Unit (ALU)](sources/ALU32Bit.v) and selects which values and control signals need to be passed further. The [MEM unit](sources/MemoryUnit.v) reads from and writes to its [data memory](sources/DataMemory.v). The [WB unit](sources/WriteBackUnit.v) writes back values to the register file used by the ID unit.

## New Pipeline Structure
Three new stages were added in the pipeline between the MEM and WB stages. The [SAD Unit](sources/SADUnit.v) performs an SAD computation on 8 columns from memory yielding 8 SAD values. The [SADD Unit](sources/SADDUnit.v) finds the smallest SAD value out of the 8 and passes to the [SSAD Unit](sources/SSADUnit.v) which compares it to the previous smallest SAD value. If the new SAD value is smaller, it stores the value and the coordinates used for the SAD computation. These stored minimum values and coordinates are passed using the [Buffer Registers](sources/BufReg.v) to the parent core's 

## Program Structure
Each core runs a single application start at address 0. The instruction and data memories are separate in the pipeline, so each of them is preloaded using its own memory file (instruction_memory.mem and data_memory.mem). Both the instruction data memories are assembled from the program's assembly file (instruction.s). The output shown on the simulation testbench waveform or the FPGA board's 8-digital 7-segment display is the new value of the register written by the parent core in the last clock cycle.

## Multi-threaded SAD algorithm
The new implementation of the SAD algorithm assigns two columns to each core for which they run a part of the SAD algorithm. After the child cores are done with their part, they forward their results to the parent core which uses them to determine the smallest SAD value and output the final coordinates for the SAD algorithm run. The new code heavily uses new custom instructions that use the new SAD stages in the pipeline capable of computing an SAD block and forwarding results to the parent core.
